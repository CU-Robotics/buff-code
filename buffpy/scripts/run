#! /usr/bin/env python3

import os 
import sys
import time
import yaml
import rospy
import signal
import roslaunch
import subprocess as sb

def load_config(target_path):
	"""
		Loda the target system config file.
		Now featuring recursive inheritance!
		PARAMS:
			file: The overwriting conf data
		RETURNS:
			case 0: empty dictionary
			case 1: the parent data (dict)
			case 2: the parent updated with the child (dict)
	"""
	if not os.path.exists(target_path):
		print(f'Could not find data dir {target_path}: ...')
		return {}

	with open(os.path.join(target_path, 'nodes.yaml'), 'r') as f:
		data = yaml.safe_load(f)

	if not data is None:
		data['self'] = target_path
		os.environ['ROBOT_NAME'] = target_path

	return data

def parse_target(robot):
	""" 
		Get target_path and config if they exist, all
		input checking debugging gets done here before launch
		PARAMS:
			args: list of strings, [file, args] args can be None
			projectRoot: filepath, root of the project
		RETURN:
			target_path: filepath, the target (yaml or py)
			target_args: args for a python script
			config: config data (dict), config for a system
	"""
	projectRoot = os.getenv('PROJECT_ROOT')	# path to project root

	config = None 
	target_args = []
	target_path = None

	target_path = os.path.join(projectRoot, 'buffpy', 'data', 'robots', robot)

	config = load_config(target_path)	# None if no config

	if config is None:
		print(f'No data in {target_path}')

	else:
		print(f'Targeting: {target_path}')

	return target_path, target_args, config

def launch_ros_core():
	# launch core
	ros_core = sb.Popen('roscore', stdout=sb.PIPE, stderr=sb.PIPE)

	launch = roslaunch.scriptapi.ROSLaunch()
	launch.start()
	return launch, ros_core

def set_ros_params(path, robot, with_xacro=False):
	namespace = '/buffbot'
	params = {'robot_name': robot}
	if (with_xacro):
		command_string = f"rosrun xacro xacro {os.path.join(path, f'buffpy/data/robots/{robot}/buffbot.xacro')}"
		robot_description = sb.check_output(command_string, shell=True, stderr=sb.STDOUT)
		params['robot_description'] = robot_description.decode()

	rospy.set_param(f'{namespace}', params)

def get_args(node_args):
	# can use args tag to send args to nodes
	args = []
	for arg in node_args:

		# find any env vars
		split1 = arg.split('{')

		n = len(split1) // 2

		if n == 0:
			args.append(arg)
			continue

		split = ''

		for i in range(n):
			split2 = split1[(2 * i) + 1].split('}')
			split += split1[2 * i][:-1] + os.getenv(split2[0]) + split2[1]

		args.append(split)

	return args

def ros_node_commands(robot, nodes, project_root):
	respawn = []
	commands = []

	# load and launch each node in the config
	for name in nodes:
		args = []
		required = False
		node = nodes[name]

		if 'package' in node:
			package = node['package']
		else:
			print(f"{name} does not specify a package")
			continue

		if 'args' in node:
			args = get_args(node['args'])

		if 'required' in node:
			required = node['required']

		# launch the process and add it to the pool
		if 'files' in node:
			for program in node['files']:
				cmd = ['rosrun', package, program] + args
				respawn.append(required)
				commands.append(cmd)

	return commands, respawn

def buff_node_commands(robot, nodes, project_root):
	respawn = []
	commands = []

	# load and launch each node in the config
	for name in nodes:
		args = []
		node = nodes[name]

		if 'args' in node:
			args = get_args(node['args'])

		if 'required' in node:
			required = node['required']
		else:
			required = False

		# launch the process and add it to the pool
		if 'files' in node:
			for program in node['files']:
				file_path = os.path.join(project_root, 'buffpy', 'lib', program)
				if '.py' == program[-3:]:
					cmd = ['python3', file_path]
				else:
					cmd = [file_path]
	
				respawn.append(required)
				commands.append(cmd + args)

	return commands, respawn

def spawn_nodes(commands):
	pool = []

	for cmd in commands:
		print(f"Starting {cmd}")
		process = sb.Popen(cmd)

		pool.append(process)

	return pool

def launch_system(robot, target_path, nodes):
	"""
		This wil launch all nodes and roscore. 
		launches core process with subprocess.Popen 
		systems are launched with the usage below
		rosrun package program args=[debug, config, topics...]
		PARAMS:
			target_path: filepath, to yaml
			config: load configuration (dict)
		RETURNS:
			core_process: subprocess obj, the core process
			pool: list of roslaunch processes
	"""
	pool = []
	ros_core = None
	ros_respawn = []
	buff_respawn = []
	ros_node_cmds = []
	buff_node_cmds = []

	project_root = os.getenv('PROJECT_ROOT')
	print(f'System Definition:\n{yaml.dump(nodes, allow_unicode=True)}\n')

	# Cant spawn pool without nodes
	if nodes is None:
		print(f'Missing NODES in config file {target_path}')

	else:
		if 'ros-nodes' in nodes:
			ros_node_cmds, ros_respawn = ros_node_commands(robot, nodes['ros-nodes'], project_root)

		if 'buff-nodes' in nodes:	
			buff_node_cmds, buff_respawn = buff_node_commands(robot, nodes['buff-nodes'], project_root)

		launch, ros_core = launch_ros_core()
		set_ros_params(project_root, robot, with_xacro=('with_xacro' in nodes))
		pool = spawn_nodes(buff_node_cmds + ros_node_cmds)
		

	return ros_core, pool, buff_respawn + ros_respawn, buff_node_cmds + ros_node_cmds

def spin(robot, config, target_path, target_args):
	"""
		initialize the run and launch
		loop and wait for user kill or core to finish
		PARAMS:
			config: a python script or system config file (yaml)
			target_path: the targetfile to launch or roscore
			target_args: arguments for the target file
	"""

	# target path is essential for launching. If it is empty
	# there was an error and the program should exit
	if target_path is None or config is None:
		print(f'Failed to load target: {target_path}')
		exit(0)

	pool = None
	launch = None
	core_process = None
	# Try to catch user kill and other errors
	try: 
		core_process, pool, respawn, commands = launch_system(robot, target_path, config)
		# core_process is the core process we are trying to spawn (python script or roscore)
		# if it fails there is no point in spinning
		if core_process is None: 
			print('Launching target core failed :(')
			exit(0)

		# this hanldes user kill (available after spawn & in the run space below)
		# this will loop until an interrupt or the core dies.
		while core_process.poll() is None:
			# if output/errors print them
			# mesg = core_process.communicate()
			# if mesg[0]:
			# 	print(mesg[0].decode('utf-8')) # this will force us to use rospy.log to print info I think
			# if mesg[1]:
			# 	print(mesg[1].decode('utf-8')) # output is sent from program to roscore then printed here

			# restart processes with the respawn flag
			if not pool is None:
				for i, proc in enumerate(pool):
					if not proc is None and not proc.poll() is None:
						if proc.returncode != 0 and respawn[i]:
							print(f'{commands[i]} died: {proc.returncode}')
							spawn_nodes(commands[i], root_shell)

	except KeyboardInterrupt as e:
		print(e)
		print('Terminate Recieved:...')

	except Exception as e:
		print(e)
		print('Killed due to error')

	if not pool is None:
		for i,proc in enumerate(pool):
			if not proc is None:
				proc.terminate()

	if not core_process is None:
		core_process.terminate()

def main(args):
	"""
		Launch all relevant pool.
		See wiki for input usage
	"""
	if len(args) < 2:
		project_root = os.getenv("PROJECT_ROOT")
		with open(os.path.join(project_root, 'buffpy', 'data', 'robots', 'self.txt'), 'r') as f:
			robot = f.read()
	else: # become the thing you want to run, sometimes I hate this
		robot = args[1]
		project_root = os.getenv("PROJECT_ROOT")
		with open(os.path.join(project_root, 'buffpy', 'data', 'robots', 'self.txt'), 'w') as f:
			f.write(robot)

	# parse the input 
	target_path, target_args, config = parse_target(robot)

	# spin till finished
	spin(robot, config, target_path, target_args) 

	print('RUN finished')
		

if __name__ == '__main__':
	main(sys.argv)


	