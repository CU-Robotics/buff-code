#!/usr/bin/env python3

import os
import sys
import yaml
import glob
import shutil
import subprocess
from tools import *

Buffpy_Path_LUT = {'lib': os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'lib'), 
					'bin': os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'bin'),
					'docs': os.path.join(os.getenv('PROJECT_ROOT'), 'documentation')}

class Build_Profile:
	def __init__(self):
		self.path = None				# Path to dir containing the project, exclude the project dir (absolute)
		self.name = None				# Name/dir of the project (relative to self.path)
		self.profile = None			# full path to profile, includes filename (absolute)
		self.setup_cmd = None		# Command to initialize the project, runs at path (ie 'cd self.path && setup_cmd')
		self.build_cmd = None		# Command to build the project (and install) runs at full_project_path()
		self.clean_cmd = None		# Command to clean the project same run location as build
		self.target_src = None		# Paths to files generated by build process (executables, binaries, etc) (relative to self.full_project_path())
		self.target_dst = None		# Paths to install files to, may be keywords

	def full_project_path(self):
		"""
			Get the absolute path to the project
			combines self.path and self.name 
		"""
		if self.name is None:
			return ""

		return os.path.join(self.path, self.name)

	def load_profile(self, profile_path, project_path):
		"""
			Parse a yaml file into a build profile
			requires a valid yaml file and project
			setup. Both paths must be absolute and 
			valid
		"""
		self.path = project_path
		self.profile = profile_path

		if not os.path.exists(self.profile):
			print(f"Can't find profile: {self.profile}")
			return

		with open(self.profile, 'r') as profile:
			contents = yaml.safe_load(profile)

		if 'project' in contents:
			self.name = contents['project']

		if 'setup' in contents:
			self.setup_cmd = contents['setup']

		if 'build' in contents:
			self.build_cmd = contents['build']

		if 'clean' in contents:
			self.clean_cmd = contents['clean']

		if "targets" in contents:
			self.target_src = contents['targets']

		if "install" in contents:
			self.target_dst = contents['install']

	def run_job(self, base_cmd, path):
		"""
			Convenience function for executing jobs
			if the base_cmd or profile is None, there
			is no job. Otherwise return the result
			of subprocess.run()
		"""
		if base_cmd is None or self.name is None:
			return None

		cmd = f'cd {path} && {base_cmd}'
		return subprocess.run(cmd, shell=True)

	def run_setup(self):
		return self.run_job(self.setup_cmd, self.path)

	def run_build(self):
		if not os.path.exists(self.full_project_path()):
			print(f"Can't find project: attempting setup ...")
			if self.run_setup() is None:
				print(f"No existing setup for project!")
				return None

		result = self.run_job(self.build_cmd, self.full_project_path())

		if self.target_dst is None or self.target_src is None:
			return None

		target_dst = [Buffpy_Path_LUT[dst] for dst in self.target_dst]
		copy_packages(self.full_project_path(), self.target_src, target_dst)

		return result

	def run_clean(self):
		if not os.path.exists(self.full_project_path()):
			print(f"Can't find project: nothing to clean")
			return None

		return self.run_job(self.clean_cmd, self.full_project_path())

	def dump_info(self):
		print(f"{self.name} profile description")
		print(f"\tprofile:\t{self.profile}")
		print(f"\tproject:\t{self.path}")
		print(f"\tsetup:\t{self.setup_cmd}")
		print(f"\tbuild:\t{self.build_cmd}")
		print(f"\tclean:\t{self.clean_cmd}")


