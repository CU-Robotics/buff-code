#!/usr/bin/env python3

import os
import sys
import yaml
import subprocess as sb

from tools import *

Buffpy_Path_LUT = {'data': os.path.join(os.getenv('PROJECT_ROOT'), 'data'),
					'lib': os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'lib'), 
					'bin': os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'bin'),
					'docs': os.path.join(os.getenv('PROJECT_ROOT'), 'documentation'),
					'models': os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'data', 'models')}

Buffpy_SRC_Path = os.path.join(os.getenv("PROJECT_ROOT"), "src")
Buffpy_Profile_Path = os.path.join(os.getenv("PROJECT_ROOT"), "buffpy", "data", "build")


class Build_Profile:
	def __init__(self):
		self.name = None			# Name/dir of the project (relative to self.path)
		self.profile = None			# full path to profile, includes filename (absolute)
		self.setup_cmd = None			# Command to initialize the project, runs at path (ie 'cd self.path && setup_cmd')
		self.build_cmd = None			# Command to build the project (and install) runs at project_path()
		self.clean_cmd = None			# Command to clean the project same run location as build
		self.target_src = []		# Paths to files generated by build process (executables, binaries, etc) (relative to self.project_path())
		self.target_dst = []		# Paths to install files to, may be keywords
		self.includes = []

	def project_path(self):
		"""
			Get the absolute path to the project
			combines self.path and self.name 
		"""
		if self.name is None:
			return ""

		return os.path.join(Buffpy_SRC_Path, self.name)

	def load_profile(self, profile):
		"""
			Parse a yaml file into a build profile
			requires a valid yaml file and project
			setup. Both paths must be absolute and 
			valid
		"""
		# Get full path
		profile_path = os.path.join(Buffpy_Profile_Path, f'{profile}.yaml')

		if not os.path.exists(profile_path):
			buff_log(f"Profile {profile_path} does not exist", 2)
			return

		with open(profile_path, 'r') as profile:
			contents = yaml.safe_load(profile)

		self.profile = profile_path

		if 'project' in contents:
			self.name = contents['project']
		else:
			self.name = ""

		if 'setup' in contents:
			self.setup_cmd = contents['setup']

		if 'build' in contents:
			self.build_cmd = contents['build']

		if 'clean' in contents:
			self.clean_cmd = contents['clean']

		if 'targets' in contents:
			self.target_src = contents['targets']

		if 'install' in contents:
			self.target_dst = contents['install']

		if 'include' in contents:
			for profile in contents['include']:
				self.includes.append(Build_Profile())
				self.includes[-1].load_profile(profile)

	def assert_setup(self):
		if self.name == "":
			buff_log(f"Virtual Project detected", 0)
			return 2

		if not os.path.exists(self.project_path()):
			buff_log(f"Can't find project: attempting setup ...", 1)
			if self.run_setup():
				buff_log(f"No existing setup for {self.name}", 2)
				return 1

		return 0

	def validate_targets(self):
		if len(self.target_dst) != len(self.target_src):
			buff_log(f"Target and install mismatch {len(self.target_src)} != {len(self.target_dst)}", 2)
			return 1

		return 0

	def validate_build(self):
		status = False
		for target in self.target_src:
			status |= not os.path.exists(os.path.join(self.project_path(), target))

		buff_log(f"{self.name} Built", 2 * status) # error if True info if False

	def validate_install(self):
		status = False
		for (src, dst) in zip(self.target_src, [Buffpy_Path_LUT[dst] for dst in self.target_dst]):
			sb.run(['chmod', '+x', os.path.join(dst, src.split('/')[-1])])
			status |= not os.path.exists(os.path.join(dst, src.split('/')[-1]))

		buff_log(f"{self.name} Installed", 2 * status) # error if True info if False

	def validate_clean(self):
		status = False
		for target in self.target_src:
			status |= os.path.exists(os.path.join(self.project_path(), target))

		buff_log(f"{self.name} Cleaned", 2 * status) # error if True info if False

	def run_job(self, base_cmd, path):
		"""
			Convenience function for executing jobs
			if the base_cmd or profile is None, there
			is no job. Otherwise return the result
			of sb.run()
		"""
		if self.name is None:
			buff_log(f"Name {self.name} is invalid", 2)
			return None

		if not base_cmd is None:
			cmd = f'cd {path} && {base_cmd}'
			sb.run(cmd, shell=True)

	def run_setup(self):
		self.run_job(self.setup_cmd, Buffpy_SRC_Path)
		buff_log(f"Finished {self.name} setup", not os.path.exists(self.project_path()))
		return not os.path.exists(self.project_path())

	def run_build(self):
		if self.assert_setup() == 0:
			if self.validate_targets():
				return

			buff_log(f"Building {self.name}", 0)
			self.run_job(self.build_cmd, self.project_path())
			self.validate_build()

			buff_log(f"Installing {self.name}", 0)
			copy_packages(self.project_path(), self.target_src, [Buffpy_Path_LUT[dst] for dst in self.target_dst])
			self.validate_install()

		for include in self.includes:
			include.run_build()

	def run_clean(self):
		if self.name != "":
			if not os.path.exists(self.project_path()):
				buff_log(f"Can't find project: nothing to clean", 1)
				return

			buff_log(f"Cleaning {self.name}", 0)
			self.run_job(self.clean_cmd, self.project_path())
			self.validate_clean()

		for include in self.includes:
			include.run_clean()

	def dump_info(self):
		print(f"{self.name} profile description")
		print(f"\tprofile:\t{self.profile}")
		print(f"\tproject:\t{Buffpy_SRC_Path}")
		print(f"\tsetup:\t{self.setup_cmd}")
		print(f"\tbuild:\t{self.build_cmd}")
		print(f"\tclean:\t{self.clean_cmd}")


