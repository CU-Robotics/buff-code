#! /usr/bin/env python3
"""
	Project: BuffPy
	author: Mitchell D Scott
	Description:
	  This is a python3 command line tool from CU-Robotics
	It is meant to simplify development of robotics software.
	Think of buff-code as a python3 app that handles the backend
	of software development:
	 - installing/setting up devices
	 - handling data
	 - testing

	  The goal is to eliminate the need for engineers to work on
	the workspace and allow them to focus on the algorithms 
	that drive the robot.

	TODO:
		debug and test all functionality (this script is woefully untested
		and will likely brake, even with standard input).

		make functionality more robust to erraneous input and general brake downs.

	NOTES:
		This program only really works once the workspace has been built.
		Which happens with the install. -- Removed GDrive_handler to fix this
"""

import os
import sys
import yaml
import shutil
import argparse
import subprocess

def parseArgs():
	"""
		Handles parsing all inputs to buff
		@PARAMS
			None
		@RETURNS
			parsedargs: argparse args object
	"""
	parser = argparse.ArgumentParser(prog=sys.argv[0],
	description='CU-Robotics Multi-Agent Deployment Manager')
	parser.add_argument('--installKeys',
		action='store_true',
		help='Push local sshkeys to the robots')
	parser.add_argument('--launch', 
		nargs=1,
		metavar='LOCATION',
		default=False,
		help='Launch the robots software on robots')
	parser.add_argument('--botPull', 
		action='store_true',
		help='Pull data from the robot at ROBOT_IP')
	parser.add_argument('--build', 
		nargs=1,
		metavar='PROFILE',
		default=False,
		help='Builds the workspace locally (debug) or to the robot_ip (install)')
	parser.add_argument('--install', 
		action='store_true',
		help='Builds the workspace locally and installs to the registered robots')
	parser.add_argument('--clean',
		action='store_true',
		help='Clean the current bin and data, NOT recoverable; only run this if you are sure you want to')

	return parser.parse_args(sys.argv[1:])

def clear_directory(path):

	# Idoit Security
	# this function could wipe the entire disk
	# if not used with caution. (its also very easy for an attacker to change an environment variable)
	if len(path.split('/')) < 3:
		print(f'Illegal Directory: cannot remove {path}')
		return

	# Remove all lib files, these are installed by catkin
	# By walking through each dir and removing its files
	# we can then delete the directories
	if os.path.exists(path):
		for root, dirs, files in os.walk(path):
			for file in files:
				os.remove(os.path.join(root, file))
			for directory in dirs:
				shutil.rmtree(os.path.join(root, directory))
			break
	else:
		os.mkdir(path)

def cleanWorkspace():
	"""
		Removes the data folder, and when it becomes necesary
		will also remove any generated binaries and configs
	"""
	data_path = os.path.join(os.getenv('PROJECT_ROOT'), 'data')
	lib_path = os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'lib')

	if not 'edge' in os.getenv('HOSTNAME'):
		result = subprocess.run(f'catkin clean -y', shell=True)

	clear_directory(data_path)
	clear_directory(lib_path)

def buildWorkspace(build):
	"""
		Builds the current workspace locally or to a robot.
		this will need to copy python files and binaries to the robot.
		@PARAMS:
			build: the profile to build
		@RETURNS:
			None
	"""
	# use catkin to clean the workspace if it was already built
	result = subprocess.run(f'catkin clean -y', shell=True)
	# clean the lib when building
	clear_directory(os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'lib'))

	# Rebuild the workspace with catkin build
	if build[0]:
		result = subprocess.run(f'catkin build --profile={build[0]}', shell=True)

	else:
		print('No profile specified exiting:...')

def get_devices():
	# load all registered devices
	config = os.path.join(os.getenv('PROJECT_ROOT'), 'buffpy', 'config', 'robots', 'robots.yaml')
	if os.path.exists(config):
		with open(config, 'r') as f:
			return yaml.safe_load(f)

def install_buffpy(botAddress, source, target, ID, botType):
	""" Install buffpy to a bot over scp
	"""

	if len(os.listdir(os.path.join(source, 'lib'))) == 0:
		print("Workspace not built, run: /'buffpy --build <profile>/'")
		return

	with open(ID, 'w+') as f:
		f.write(f"FROM:\n  '{botType}.yaml'\n")
	# if root does exist remove it
	result1 = subprocess.run(['ssh', botAddress, f'if [[ -d {target} ]]; then rm -rf {target}; fi; mkdir {target}'])
	if result1.returncode == 0:
		result2 = subprocess.run(['scp', '-r', source, f'{botAddress}:{target}'])
		if result2.returncode == 0:
			print(f'Successfuly installed to {botAddress}')

		else:
			print(f'Install Error: {result2}')

	else:
		print(f'{result1}')


def install_all_devices():
	"""
		Install all built code to all robots
	"""

	# Don't build on edge devices (robot)
	if 'edge' in os.getenv('HOSTNAME'):
		print(f"Can/'t build on device: {os.getenv('HOSTNAME')}")
		return

	devices = get_devices()

	# Setup Parameters for install
	target = os.path.join('/home', 'cu-robotics', 'buff-code')
	project_root = os.getenv('PROJECT_ROOT')
	source = os.path.join(project_root, 'buffpy')
	ID = os.path.join(project_root, 'buffpy', 'config', 'robots', 'self.yaml')

	for robot in devices:
		botType = devices[robot]

		# set target destination
		botAddress = f'cu-robotics@{robot}.local'

		install_buffpy(botAddress, source, target, ID, botType)

def install_ssh_keys():
	devices = get_devices()

	if not os.path.exists('~/.ssh/id_ed25519.pub'):
		result = subprocess.run(['ssh-keygen', '-t', 'ed25519'])

	for robot in devices:
		result = subprocess.run(['ssh-copy-id', '-i', f'~/.ssh/id_ed25519.pub cu-robotics@{robot}.local'])
		if result.returncode == 0:
			print(f'{robot} -> {result}')

def main(ap):

	if ap.clean:
		cleanWorkspace()

	if ap.installKeys:
		install_ssh_keys()

	if ap.build:
		buildWorkspace(ap.build)

	if ap.install:
		install_all_devices()

	# May be Deprecated
	if ap.launch == 'bot':
		result = subprocess.run(['ssh', os.getenv("ROBOT_ADDRESS"), 'cd buff-code && source buff.bash && launch'])

	if ap.botPull:
		result = subprocess.run(['scp', f'{os.getenv("ROBOT_ADDRESS")}:{os.getenv("ROBOT_ROOT")}/data', f'{os.getenv("PROJECT_ROOT")}/data'])

if __name__ == '__main__':
	ap = parseArgs()
	main(ap)

