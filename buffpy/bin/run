#! /usr/bin/env python3
"""
		Launcher 
 	This is the main script for all CV 
	operations. The script launches the 
	camera stream, models and the serial
	communications.
	
	TODO:
		Create a manager for all spawned processes.
	The manager will need to print a runtime state every so
	often and kill processes when necesary.
"""

import os 
import sys
import time
import rospy
import signal
import subprocess as sb


def main(args):
	"""
		Launch all relevant processes. (could be replaced with roslaunch)
	"""

	# Get the program file name and directory
	fileName = args[0]
	path = os.path.dirname(fileName)

	# Get the project root and create a path to buffvision.py
	projectRoot = os.getenv('PROJECT_ROOT')
	bvScript = os.path.join(projectRoot, 'buffpy', 'lib', 'buffvision.py')

	# list of the programs to launch
	programs = ['roscore', bvScript]

	# parse the args
	if len(args) > 1:
		for arg in args[1:]:
			cmd = arg.split(':')
			script = cmd[0]
			# if .py is in the name its a python script
			if script[-3:] == '.py':
				# combine script and args into command for Popen
				command = [os.path.join(projectRoot, 'buffpy', 'lib', script)]
				for param in cmd[1:]:
					command.append(param)

				programs.append(command)
			# if no-core don't launch the core
			if script == 'no-core':
				if len(programs) > 1:
					programs = programs[2:]

				else:
					programs = []

	processes = []

	for p in programs:
		print(f'spawning: {p}')
		processes.append(sb.Popen(p, stdout=sb.PIPE, stderr=sb.PIPE))
		if p == 'roscore':
			rospy.init_node('buff_spawner', anonymous=True)

	#	Important # DEPRECATED now kills all spawned processes
	# Wait for rospy to shutdown before exiting
	# when it gets implemented this will help kill
	# running processes. Will kill ROScore when ^c
	# recieved. Other processes need to terminate 
	# themselves (by polling roscore.is_shutdown).
	try:
		print(f'Running live')
		# while any process is running stay alive
		is_alive = True
		while is_alive:
			is_alive = False
			for proc in processes:
				# poll all processes
				ret_code = proc.poll()
				if ret_code is None:
					# check the process for errors
					mesg = proc.communicate()
					if mesg[0]:
						print(mesg[0].decode('utf-8'))
					if mesg[1]:
						print(mesg[1].decode('utf-8'))
					is_alive = True

	except KeyboardInterrupt as e:
		print(e)
		print(f'Terminate Recieved:...')
		for proc in processes:
			os.kill(proc.pid, signal.SIGTERM)

	print('RUN finished:...')

if __name__ == '__main__':
	main(sys.argv)